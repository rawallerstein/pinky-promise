First, let's talk about promises

As far as I can tell we have a few rules we MUST follow when extending the base JavaScript Promise.

1. The constructor must be able to receive an argument
2. That argument must be considered for the executor passed to the super. I'm not 100% on the logic for this, but you can NOT pass an executor to super without at least trying to pass the constructor's argument. Notice, we have 4 ways to construct a PinkyPromise at this time and one of them can happen when the constructor's param is undefined. But we always check for param when making the executor. I have no idea why some methods work and others dont, but here we are.
3. Thens and catches put on the Promise passed to the constructor from outside WILL be called along with any thens or catches of our own. But, since we can't reliably access the executor argument for the "Foreign Promise", we have to resolve our PinkyPromise with the then of the Foreign Promise. This is not any kind of special behavior though, as thens put on the same promise in multiple places will also all run. We can think of the foreign promise's PinkyPromise then as a "propagated then" that we can add things to from elsewhere.
4. Promises can be silently resolved or rejected (idempotently) several times. On first fulfillment, a Promise will retain that state and value and only fire its then once ever. I'd like to see if we can make this happen non-idempotently as an option for the user. For a use case, a user may want to trigger a then several times. "Why not just call a function each time?" You could do that, but if we can let promises fire their then multiple times, we could have a cool way to keep a reactive state. If you're using Vue or React you might not want this, but for projects that don't handle reactivity for you, this could be useful. To be honest, this would just be a crap version of event.js so maybe not. But the idea certainly feels worth investigating!
5. We let users force resolve or reject on their promise because sometimes you just need to do that. The entire thesis of this library is "Make Better Promises" and that mean giving devs more control. I made this because I often find myself needing to resolve a promise from somewhere else and I honestly HATE having to set up some stupid Promise keeping object. Let devs be able to decide WHEN to resolve a promise. Also, I hate not being able to check the state of a Promise (fulfilled, rejected, resolved). You might say I can just add it to the Promise keeping object from earlier, but then we might as well build something that does all that crap for us. Does it need to have all these features? No, which is why I will be providing a simple, lightweight constructor that gives you a tiny pinky promise (idk what to call it) alongside the more robust PinkyPromise class.
